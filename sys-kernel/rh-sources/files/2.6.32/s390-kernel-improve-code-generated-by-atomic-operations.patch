From: Hendrik Brueckner <brueckner@redhat.com>
Date: Wed, 16 Dec 2009 10:19:32 -0500
Subject: [s390] kernel: improve code generated by atomic operations
Message-id: <20091216101932.GA18605@redhat.com>
Patchwork-id: 21997
O-Subject: [RHEL6 PATCH 1/1] [s390] kernel: improve code generated by atomic
	operations
Bugzilla: 547411
RH-Acked-by: Pete Zaitcev <zaitcev@redhat.com>

Description
-----------
The compiler generates slow code for atomic operations.

The GIT commit ea435467500612636f8f4fb639ff6e76b2496e4b
changed the definition of atomic_t and atomic64_t for
s390 by adding the volatile modifier to the counter
field.
This has an unfortunate side effect with newer versions of the gcc.
The typeof operator now picks up the volatile modifier from the
expression. This causes the compiler to think that it has to store
the two temporary variable old_val and new_val in the __CS_LOOP for
the different atomic operations to the stack as the variables
are now volatile. Both stores are superfluous.

The solution is to replace typeof(ptr->counter) with int in __CS_LOOP
and long long in __CSG_LOOP.

Bugzilla
--------
BZ 547411
https://bugzilla.redhat.com/show_bug.cgi?id=547411

Upstream status of the patch
----------------------------
The patch will be upstream as of kernel version 2.6.33
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=39475179d40996b4efa662e3825735a84d2526d1

Test status
-----------
The patch has been tested and fixes the problem.
The fix has been verified by the IBM test department.

Please ACK.

With best regards,

	Hendrik

Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>

diff --git a/arch/s390/include/asm/atomic.h b/arch/s390/include/asm/atomic.h
index ae7c8f9..2a113d6 100644
--- a/arch/s390/include/asm/atomic.h
+++ b/arch/s390/include/asm/atomic.h
@@ -21,7 +21,7 @@
 #if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 2)
 
 #define __CS_LOOP(ptr, op_val, op_string) ({				\
-	typeof(ptr->counter) old_val, new_val;				\
+	int old_val, new_val;						\
 	asm volatile(							\
 		"	l	%0,%2\n"				\
 		"0:	lr	%1,%0\n"				\
@@ -38,7 +38,7 @@
 #else /* __GNUC__ */
 
 #define __CS_LOOP(ptr, op_val, op_string) ({				\
-	typeof(ptr->counter) old_val, new_val;				\
+	int old_val, new_val;						\
 	asm volatile(							\
 		"	l	%0,0(%3)\n"				\
 		"0:	lr	%1,%0\n"				\
@@ -143,7 +143,7 @@ static inline int atomic_add_unless(atomic_t *v, int a, int u)
 #if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 2)
 
 #define __CSG_LOOP(ptr, op_val, op_string) ({				\
-	typeof(ptr->counter) old_val, new_val;				\
+	long long old_val, new_val;					\
 	asm volatile(							\
 		"	lg	%0,%2\n"				\
 		"0:	lgr	%1,%0\n"				\
@@ -160,7 +160,7 @@ static inline int atomic_add_unless(atomic_t *v, int a, int u)
 #else /* __GNUC__ */
 
 #define __CSG_LOOP(ptr, op_val, op_string) ({				\
-	typeof(ptr->counter) old_val, new_val;				\
+	long long old_val, new_val;					\
 	asm volatile(							\
 		"	lg	%0,0(%3)\n"				\
 		"0:	lgr	%1,%0\n"				\
